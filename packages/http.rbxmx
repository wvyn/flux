<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
<Meta name="ExplicitAutoJoints">true</Meta>
<Item class="ModuleScript" referent="RBXWEMR6SREGJWV6INZPAKGA6O84IT1JQIS">
<Properties>
<string name="Name">http</string>
<string name="ScriptGuid">{c3ab19ca-fc36-44ee-8810-4cfab7b19ac0}</string>
<ProtectedString name="Source"><![CDATA[local httpService = game:GetService("HttpService")

local http = { 
	JSON = {},
	Encryption = require("@self/Encryption")
}

export type Headers = {
	authorization: string?,                   -- Bearer token or other authorization methods
	accept: string?,                          -- Media types (e.g., "application/json")
	["accept-encoding"]: string?,             -- Acceptable encodings (e.g., "gzip, deflate")
	["content-type"]: string?,                -- Content type (e.g., "application/json")
	["content-length"]: number?,              -- Length of the body in bytes
	["user-agent"]: string?,                  -- User agent string (browser or client)
	host: string?,                            -- Domain name (required in HTTP/1.1)
	referer: string?,                         -- URL of the referring page
	cookie: string?,                          -- Cookies (name=value pairs)
	["cache-control"]: string?,               -- Caching instructions (e.g., "no-cache")
	["if-modified-since"]: string?,           -- Last modification date (e.g., "Wed, 21 Oct 2015 07:28:00 GMT")
	["accept-language"]: string?,             -- Language preferences (e.g., "en-US,en;q=0.9")
	connection: string?,                      -- Connection control (e.g., "keep-alive")
	["x-csrf-token"]: string?,                -- CSRF Token for security (e.g., anti-CSRF protection)
	["authorization-token"]: string?,         -- Token for custom authorization (if needed)
	["x-requested-with"]: string?,            -- Usually "XMLHttpRequest" for AJAX requests
	["upgrade-insecure-requests"]: number?,   -- Whether to upgrade HTTP to HTTPS
	["strict-transport-security"]: string?,   -- Enforces secure connections (e.g., "max-age=31536000; includeSubDomains")
	["access-control-allow-origin"]: string?, -- CORS header allowing cross-origin requests

	-- Additional headers:
	["x-frame-options"]: string?,             -- Controls whether the browser can display content in a <frame>, <iframe>, etc. (for clickjacking protection)
	["x-content-type-options"]: string?,      -- Prevents MIME-sniffing (e.g., "nosniff")
	["content-encoding"]: string?,            -- Specifies encoding transformations applied to the body (e.g., "gzip")
	etag: string?,                            -- Unique identifier for a resource version, used in caching
	["if-none-match"]: string?,               -- Conditional GET requests based on ETag
	["if-range"]: string?,                    -- Allows partial content requests (if resource hasnâ€™t changed)
	range: string?,                           -- Requests specific byte range (e.g., "bytes=500-999")
	["x-powered-by"]: string?,                -- Information about the technology used by the server (e.g., "PHP/7.4.3")
	date: string?,                            -- Date and time of the message's creation
	origin: string?,                          -- CORS: Origin of the request
	server: string?,                          -- Information about the software used by the origin server (e.g., "nginx/1.19.6")
	vary: string?,                            -- Specifies how the response varies based on request headers (e.g., "Accept-Encoding")
	["content-disposition"]: string?,         -- Instructs how to handle content (e.g., "attachment; filename=example.txt")
	["accept-ranges"]: string?,               -- Indicates the types of ranges the server supports (e.g., "bytes")
	["x-request-id"]: string?,                -- Unique ID for the request (for tracing purposes)
	["x-real-ip"]: string?,                   -- The real IP address of the client (often used in reverse proxy setups)
	["x-forwarded-for"]: string?,             -- A list of IP addresses the request has passed through (useful for reverse proxies)
	["x-xss-protection"]: string?,            -- Cross-site scripting (XSS) filter settings (e.g., "1; mode=block")
}


export type Method = "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "OPTIONS" | "TRACE" | "PATCH"

export type RequestResponse = {
	Success: boolean,
	StatusCode: number,
	StatusMessage: string,
	Headers: Headers,
	Body: any
}

function http:Post(
	options: {
		url: string,
		data: string,
		content_type: Enum.HttpContentType?,
		compress: boolean?,
		headers: Headers?
	}
)
	return httpService:PostAsync(options.url, options.data, options.content_type, options.compress, options.headers)
end

function http:Get(
	options: {
		url: string,
		nocache: boolean?,
		headers: Headers?,
	}
)
	return httpService:GetAsync(options.url, options.nocache, options.headers)
end

function http:Request(
	options: {
		url: string,
		method: Method,
		headers: Headers?,
		body: string?,
		compress: Enum.HttpCompression?
	}
): RequestResponse
	local body = options.body
	return httpService:RequestAsync({
		Url = options.url,
		Method = options.method,
		Headers = options.headers,
		Body = typeof(body) == "table" and http.JSON:Encode(body) or body,
		Compress = options.compress
	})
end

function http:UrlEncode(url: string)
	return httpService:UrlEncode(url)
end

function http.JSON:Encode(input: string)
	return httpService:JSONEncode(input)
end

function http.JSON:Decode(input: string)
	return httpService:JSONDecode(input)
end

return http]]></ProtectedString>
</Properties>
<Item class="ModuleScript" referent="RBXEAKWM9M43JFDZECU2YN4ASG0RYJ2BTEO">
<Properties>
<string name="Name">Encryption</string>
<string name="ScriptGuid">{1557325b-3db1-429f-9480-3f0949763207}</string>
<ProtectedString name="Source"><![CDATA[local Encryption = {
	Base64 = {}
}

local stringByte = string.byte
local stringChar = string.char

local mathFloor = math.floor

local tableConcat = table.concat
local tableRemove = table.remove

local rshift = bit32.rshift

local base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
function Encryption.Base64:Encode(input: string)
	local output = {}
	local padding = ""

	if #input % 3 == 1 then
		padding = "=="
		input = input .. "\0\0"
	elseif #input % 3 == 2 then
		padding = "="
		input = input .. "\0"
	end

	for i = 1, #input, 3 do
		local byte1 = stringByte(input, i)
		local byte2 = stringByte(input, i + 1)
		local byte3 = stringByte(input, i + 2)

		local index1 = mathFloor(byte1 / 4)
		local index2 = ((byte1 % 4) * 16) + mathFloor(byte2 / 16)
		local index3 = ((byte2 % 16) * 4) + mathFloor(byte3 / 64)
		local index4 = byte3 % 64

		output[#output + 1] = base64Chars:sub(index1 + 1, index1 + 1)
		output[#output + 1] = base64Chars:sub(index2 + 1, index2 + 1)
		output[#output + 1] = base64Chars:sub(index3 + 1, index3 + 1)
		output[#output + 1] = base64Chars:sub(index4 + 1, index4 + 1)
	end

	local result = tableConcat(output)
	return result:sub(1, #result - #padding) .. padding
end

function Encryption.Base64:Decode(encodedStr)
	local decodedStr = {}
	encodedStr = encodedStr:gsub("[^A-Za-z0-9+/=]", "")
	encodedStr = encodedStr:gsub("=*$", "")
	for i = 1, #encodedStr, 4 do
		local a, b, c, d = encodedStr:sub(i, i), encodedStr:sub(i + 1, i + 1), encodedStr:sub(i + 2, i + 2), encodedStr:sub(i + 3, i + 3)
		
		local n1 = base64Chars:find(a)
		local n2 = base64Chars:find(b)
		local n3 = base64Chars:find(c)
		local n4 = base64Chars:find(d)

		n1 = n1 - 1
		n2 = n2 - 1
		n3 = n3 - 1
		n4 = n4 - 1

		local combined = (n1 * 2^18) + (n2 * 2^12) + (n3 * 2^6) + n4

		decodedStr[#decodedStr + 1] = stringChar(rshift(combined, 16) % 256)
		decodedStr[#decodedStr + 1] = stringChar(rshift(combined, 8) % 256)
		decodedStr[#decodedStr + 1] = stringChar(combined % 256)
	end

	return tableConcat(decodedStr)
end


return Encryption]]></ProtectedString>
</Properties>
<Item class="ModuleScript" referent="RBXKFBCEKT3JVV1V4PUGMN4NCN5R65I3JHI">
<Properties>
<string name="Name">RBXM</string>
<string name="ScriptGuid">{391d8665-25cb-4857-9a08-5786fd117360}</string>
<ProtectedString name="Source"><![CDATA[local httpService = game:GetService("HttpService")
local scriptEditorService = game:GetService("ScriptEditorService")

local RBXM = {}

local function referent()
	local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	local result = ""
	for i = 1, 32 do
		local index = math.random(1, #chars)
		result = result .. chars:sub(index, index)
	end; return result
end

local function loopInstances(bufferArray: { string }, instances: { Instance })
	for _, instance in next, instances do
		bufferArray[#bufferArray + 1] = `<Item class="{instance.ClassName}" referent="RBX{referent()}">`
		bufferArray[#bufferArray + 1] = `<Properties>`
		bufferArray[#bufferArray + 1] = `<string name="Name">{instance.Name}</string>`
		if instance:IsA("BaseScript") or instance:IsA("ModuleScript") then
			bufferArray[#bufferArray + 1] = `<string name="ScriptGuid">{httpService:GenerateGUID()}</string>`
			bufferArray[#bufferArray + 1] = `<ProtectedString name="Source"><![CDATA[` .. scriptEditorService:GetEditorSource(instance) .. `]]></ProtectedString>`
		end
		bufferArray[#bufferArray + 1] = `</Properties>`
		loopInstances(bufferArray, instance:GetChildren())
		bufferArray[#bufferArray + 1] = `</Item>`
	end
end

function RBXM:GetXML(instances: { Instance })
	local bufferArray = {
		`<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">`,
		`<Meta name="ExplicitAutoJoints">true</Meta>`,
	}
	
	loopInstances(bufferArray, instances)
	
	bufferArray[#bufferArray + 1] = `</roblox>`
	return table.concat(bufferArray, "\n")
end

export type RBXMInstance = {
	ClassName: string,
	Referent: string,
	Name: string,
	
	Children: RBXMInstance,
	Parent: RBXMInstance?,
	
	Source: string?,
	ScriptGuid: string?
}

local function parseItem(xmlItem)
	local instance = {}

	local className, referent = xmlItem:match('<Item class="(.-)" referent="(.-)"')
	if className then
		instance.ClassName = className
	end; if referent then
		instance.Referent = referent
	end

	local name = xmlItem:match('<string name="Name">(.-)</string>')
	if name then
		instance.Name = name
	end

	if xmlItem:match('<string name="ScriptGuid">') then
		instance.ScriptGuid = xmlItem:match('<string name="ScriptGuid">(.-)</string>')
		local source = xmlItem:match('<ProtectedString name="Source"><!%[CDATA%[(.-)%]%]></ProtectedString>')
		if source then
			instance.Source = source
		end
	end

	return instance
end

local function extractItems(xml: string)
	local pointer = 1
	local function nextTag()
		return xml:find("<", pointer)
	end

	local function parseItem()
		local class, referent = xml:match('<Item class="(.-)" referent="(.-)">', pointer)
		local startTag = xml:find('<Item class="(.-)" referent="(.-)">', pointer)
		if not startTag then return end

		local instance = {
			ClassName = class,
			Referent = referent,
		}

		pointer = xml:find("<Properties>", startTag)
		if not pointer then return end

		local propClose = xml:find("</Properties>", pointer)
		local propBlock = xml:sub(pointer, propClose + 12)
		pointer = propClose + 13

		instance.Name = propBlock:match('<string name="Name">(.-)</string>')
		instance.ScriptGuid = propBlock:match('<string name="ScriptGuid">(.-)</string>')
		instance.Source = propBlock:match('<ProtectedString name="Source"><!%[CDATA%[(.-)%]%]></ProtectedString>')

		instance.Children = {}

		while true do
			local nextItemStart = xml:find("<Item", pointer)
			local nextItemEnd = xml:find("</Item>", pointer)
			if not nextItemStart or nextItemEnd < nextItemStart then
				pointer = nextItemEnd and (nextItemEnd + 7) or pointer
				break
			end

			local child = parseItem()
			if child then
				child.Parent = instance
				instance.Children[#instance.Children + 1] = child
			end
		end

		return instance
	end

	local results = {}
	while pointer < #xml do
		local i = parseItem()
		if i then results[#results + 1] = i; for _, v in next, i.Children do results[#results + 1] = v end else break end
	end
	
	return results
end

function RBXM:GetInstances(content: string): { RBXMInstance }
	return extractItems(content)
end


return RBXM]]></ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBXT1IYHKGLIE17I5NWW4HZQRHWRQMTXQOW">
<Properties>
<string name="Name">Signal</string>
<string name="ScriptGuid">{de7edd8e-f679-468d-8b68-a2082c7c7b17}</string>
<ProtectedString name="Source"><![CDATA[local SignalConstructor = {}
local SignalMethods = {}

local tableRemove = table.remove
local tableFind = table.find

local coroutineRunning = coroutine.running
local coroutineYield = coroutine.yield

local taskDelay = task.delay
local taskCancel = task.cancel

function SignalConstructor.new()
	return setmetatable({ _connections = {} :: { SignalConnection } }, { __index = SignalMethods })
end

local taskSpawn = task.spawn
function SignalMethods:Fire<parameters...>(...: parameters...): parameters...
	for _, connection in next, self._connections do
		taskSpawn(connection[1], ...)
	end; return ...
end

function SignalMethods:Invoke<parameters...>(...: parameters...): { any }
	local responses = {}
	for _, connection in next, self._connections do
		responses[#responses + 1] = connection[1](...) or false
	end; return responses
end

local Connection = {}
function Connection:Disconnect()
	local _, connections = unpack(self)

	local connectionIndex = tableFind(connections, self)
	if connectionIndex then
		tableRemove(connections, connectionIndex)
	end
end

function SignalMethods:Connect(func: () -> (), ...)
	if ... then
		local subFunction = func
		local parameters = {...}
		func = function() subFunction(unpack(parameters)) end 
	end

	local connections = self._connections
	local SignalConnection = setmetatable({ func, connections }, { __index = Connection })
	connections[#connections + 1] = SignalConnection
	return SignalConnection
end

function SignalMethods:DisconnectAll()
	local connections = self._connections
	for connectionIndex in next, connections do
		connections[connectionIndex] = nil
	end
end

function SignalMethods:Wait(timeout: number?)
	local thread = coroutineRunning()

	local connection

	local timeoutThread
	if timeout then
		timeoutThread = taskDelay(timeout, function() 
			connection:Disconnect(); 
			connection = nil; 

			timeoutThread = nil;

			taskSpawn(thread)
		end)
	end

	connection = self:Connect(function(...)
		connection:Disconnect()
		taskSpawn(thread, ...)
		if timeoutThread then 
			taskCancel(timeoutThread);
			timeoutThread = nil 
		end
	end)

	return coroutineYield()
end

function SignalMethods:Once(func: () -> (), ...)
	if ... then
		local subFunction = func
		local parameters = {...}
		func = function() subFunction(unpack(parameters)) end 
	end

	local connection
	connection = self:Connect(function(...)
		connection:Disconnect()
		connection = nil

		taskSpawn(func, ...)
	end)

	return connection
end

function SignalMethods:Destroy()
	self:DisconnectAll()

	local connections = self._connections
	for i in next, connections do
		connections[i] = nil
	end

	for i in next, self do
		self[i] = nil
	end

	setmetatable(self, nil)
	return true
end

export type SignalConnection = typeof(Connection)
export type Signal = typeof(SignalConstructor.new())

return SignalConstructor]]></ProtectedString>
</Properties>
</Item>
<Item class="ModuleScript" referent="RBX9HDTC0LIGU9GLCNFXM7YRFNFLEB3JXU1">
<Properties>
<string name="Name">Logs</string>
<string name="ScriptGuid">{69c554a6-3839-47e6-9de8-3059d2f3a630}</string>
<ProtectedString name="Source"><![CDATA[local Signal = require("./Signal")

local Logs = {}
local LogMethods = {}

local tableRemove = table.remove
local tableFind = table.find

function LogMethods.Continue(self: Logs, log: string)
	local lines = log:split("\n")
	if self[#self] then
		self[#self] ..= lines[1]
	else
		self[#self + 1] = lines[1]
	end; for i = 2, #lines do
		self:Push(lines[i])
	end
	return lines
end

function LogMethods.Push(self: Logs, log: string)
	local index = #self + 1
	self[index] = log
	return index
end

function LogMethods.Find(
	self: Logs,
	options: {
		exact: string?,
		startsWith: string?,
		endsWith: string?,
		contains: string?,
		lowercaseExact: string?,
		lowercaseContains: string?
	}
)
	for index, log in next, self do
		if options.exact and log == options.exact then
			return index, log
		elseif options.startsWith and log:sub(1, #options.startsWith) == options.startsWith then
			return index, log
		elseif options.endsWith and log:sub(-#options.endsWith) == options.endsWith then
			return index, log
		elseif options.contains and log:find(options.contains) then
			return index, log
		elseif options.lowercaseExact and log:lower() == options.lowercaseExact:lower() then
			return index, log
		elseif options.lowercaseContains and log:lower():find(options.lowercaseContains:lower()) then
			return index, log
		end
	end
end

function LogMethods.RemoveIndex(self: Logs, index: number): string
	local value = tableRemove(self, index)
	return value
end

function LogMethods.RemoveValue(self: Logs, value: string): number
	local index = self:Find({ exact = value })
	if index then self:RemoveIndex(index) end
	return index
end

function LogMethods.Clear(self: Logs)
	local itemsCleared = #self
	for i = 1, itemsCleared do
		self[i] = nil
	end
	return itemsCleared
end

function LogMethods.Destroy(self: Logs)
	for i in next, self do self[i] = nil end
	setmetatable(self, {})
	return nil
end

function Logs.new(events: boolean?)
	return setmetatable({}, { __index = LogMethods })
end

export type Logs = typeof(Logs.new())

return Logs]]></ProtectedString>
</Properties>
</Item>
</Item>
</Item>
</roblox>
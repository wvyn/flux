<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXF1A76F74BDD540D7A907E1ED308DCBCC">
		<Properties>
			<Content name="LinkedSource"><null></null></Content>
			<ProtectedString name="Source"><![CDATA[local Assembly = require("@self/Assembly")
local Replicator = require("@self/Replicator")

local InstanceReplicator = {}

function InstanceReplicator.new()
	return Assembly.new()
end

function InstanceReplicator.fromAssembly(instructions: { any })
	local references = {}
	for i = 1, #instructions do
		local instruction = instructions[i]
		local response = Replicator.readInstruction(references, instruction)
		if response == "__ASSEMBLYEXIT__" then
			return
		end
	end
end

return InstanceReplicator]]></ProtectedString>
			<string name="ScriptGuid">{7816ED87-D379-4A05-A10E-F66CAE1F8AAC}</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InstanceReplicator</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXC7D6C0C723B24568A71B44B7CA4A1299">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local Assembly = {}
local AssemblyMethods = {}

function Assembly.new()
	return setmetatable({
		Instructions = {}
	}, { __index = AssemblyMethods })
end

function AssemblyMethods.Clone(self: Assembly, reference: any, assignReference: any)
	self.Instructions[#self.Instructions + 1] = { "Clone", reference, assignReference }
	return assignReference
end

function AssemblyMethods.SetReference(self: Assembly, reference: any, pathReference: string, pathParent: (Instance | { string } | string)?)
	self.Instructions[#self.Instructions + 1] = { "SetReference", reference, pathReference, pathParent }
end

function AssemblyMethods.SetReferenceValue(self: Assembly, reference: any, value: any)
	self.Instructions[#self.Instructions + 1] = { "SetReferenceValue", reference, value }
end

function AssemblyMethods.SetDeepFindReference(self: Assembly, reference: any, deepFind: string, parentPath: (Instance | { string } | string)?)
	self.Instructions[#self.Instructions + 1] = { "SetDeepFindReference", reference, deepFind, parentPath }
end

function AssemblyMethods.SetWaitingReference(self: Assembly, reference: any, pathReference: string, timeout: number, parentPath: (Instance | { string } | string)?)
	self.Instructions[#self.Instructions + 1] = { "SetWaitingReference", reference, pathReference, parentPath, timeout }
end

function AssemblyMethods.SetNotReference(self: Assembly, reference: any, resultReference: any)
	local instruction = { "SetNotReference", reference, resultReference }
	if resultReference then self.Instructions[#self.Instructions + 1] = instruction end
	return instruction
end

function AssemblyMethods.CompareReferences(self: Assembly, referenceA: any, referenceB: any, resultReference: any)
	local instruction = { "CompareReferences", referenceA, referenceB, resultReference }
	if resultReference then self.Instructions[#self.Instructions + 1] = instruction end
	return instruction
end

function AssemblyMethods.CompareGreaterThanReferences(self: Assembly, referenceA: any, referenceB: any, resultReference: any)
	local instruction = { "CompareGreaterThanReferences", referenceA, referenceB, resultReference }
	if resultReference then self.Instructions[#self.Instructions + 1] = instruction end
	return instruction
end

function AssemblyMethods.CompareLessThanReferences(self: Assembly, referenceA: any, referenceB: any, resultReference: any)
	local instruction = { "CompareLessThanReferences", referenceA, referenceB, resultReference }
	if resultReference then self.Instructions[#self.Instructions + 1] = instruction end
	return instruction
end

function AssemblyMethods.SetReferenceStringConcat(self: Assembly, referenceA: any, referenceB: any, resultReference: any)
	local instruction = { "SetReferenceStringConcat", referenceA, referenceB, resultReference }
	if resultReference then self.Instructions[#self.Instructions + 1] = instruction end
	return instruction
end

function AssemblyMethods.SetInstructionConditionBlock(self: Assembly, conditionReference: any, compliedInstructions: { any })
	self.Instructions[#self.Instructions + 1] = { "SetInstructionConditionBlock", conditionReference, compliedInstructions }
end

function AssemblyMethods.Print(self: Assembly, reference: any)
	self.Instructions[#self.Instructions + 1] = { "Print", reference }
end

function AssemblyMethods.Warn(self: Assembly, reference: any)
	self.Instructions[#self.Instructions + 1] = { "Warn", reference }
end

function AssemblyMethods.ExitCondition(self: Assembly, reference: any)
	self.Instructions[#self.Instructions + 1] = { "ExitCondition", reference }
end

function AssemblyMethods.GetReference(self: Assembly, reference: any)
	local referenceInstruction = { "GetReference", reference, IsReference = true }
	return referenceInstruction
end

function AssemblyMethods.SetProperty(self: Assembly, reference: any, property: string, value: any)
	self.Instructions[#self.Instructions + 1] = { "SetProperty", reference, property, value }
end

function AssemblyMethods.Add(self: Assembly, reference: any, value: any)
	return { "Add", reference, value }
end

function AssemblyMethods.GetProperty(self: Assembly, reference: any, property: string, assignReference: any)
	local property = { "GetProperty", reference, property, assignReference }
	if assignReference then self.Instructions[#self.Instructions + 1] = property end
	return property
end

function AssemblyMethods.CallMethod<parameters>(self: Assembly, reference: any, method: string, ...: parameters)
	self.Instructions[#self.Instructions + 1] = { "CallMethod", reference, method, { ... } }
end

function AssemblyMethods.CompileRaw(self: Assembly)
	return self.Instructions
end

export type Assembly = typeof(Assembly.new())

return Assembly]]></ProtectedString>
				<string name="ScriptGuid">{6AC430C2-30A6-4834-BED2-FD3A44FACE41}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Assembly</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX1E5E379F21D0419E8AB4BFB5E80A302C">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local Replicator = {}

local function getInstanceFromReference(references: {}, path: string, parent: (Instance | {  })?, deepEnd: boolean?, waitTimeout: number?)
	parent = parent or game
	if not parent then return end
	if typeof(parent) == "table" and parent.IsReference then
		parent = references[parent[2]]
	elseif typeof(parent) == "string" then
		parent = references[parent]
	end
	
	local instance = parent
	if not instance then return end
	local paths = path:split("/")
	for index, route in next, paths do
		if waitTimeout then
			instance = instance:WaitForChild(route, waitTimeout)
		else
			instance = instance:FindFirstChild(route, deepEnd and index == #paths)
		end
		if not instance then break end
	end
	
	return instance
end

local function readInstruction(references: {}, instruction: any)
	if instruction[1] == "SetReference" then
		references[instruction[2]] = getInstanceFromReference(references, instruction[3], instruction[4])
	elseif instruction[1] == "SetReferenceValue" then
		references[instruction[2]] = instruction[3]
	elseif instruction[1] == "SetDeepFindReference" then
		references[instruction[2]] = getInstanceFromReference(references, instruction[3], instruction[4], true)
	elseif instruction[1] == "SetWaitingReference" then
		references[instruction[2]] = getInstanceFromReference(references, instruction[3], instruction[4], false, instruction[5])
	elseif instruction[1] == "SetNotReference" then
		local result = not references[instruction[2]]
		if instruction[3] then references[instruction[3]] = result end
		return result
	elseif instruction[1] == "CompareReferences" then
		local result = references[instruction[2]] == references[instruction[3]]
		if instruction[4] then references[instruction[4]] = result end
		return result
	elseif instruction[1] == "CompareGreaterThanReferences" then
		local result = references[instruction[2]] > references[instruction[3]]
		if instruction[4] then references[instruction[4]] = result end
		return result
	elseif instruction[1] == "CompareLessThanReferences" then
		local result = references[instruction[2]] < references[instruction[3]]
		if instruction[4] then references[instruction[4]] = result end
		return result
	elseif instruction[1] == "SetReferenceStringConcat" then
		local result = (references[instruction[2]] or "")..(references[instruction[3]] or "")
		if instruction[4] then references[instruction[4]] = result end
		return result
	elseif instruction[1] == "SetInstructionConditionBlock" then
		if references[instruction[2]] then
			for _, blockInstructions in next, instruction[3] do
				readInstruction(references, blockInstructions)
			end
		end
	elseif instruction[1] == "SetProperty" then
		local value = typeof(instruction[4]) == "table" and readInstruction(references, instruction[4]) or instruction[4]
		references[instruction[2]][instruction[3]] = value
	elseif instruction[1] == "Print" then
		print(references[instruction[2]])
	elseif instruction[1] == "Warn" then
		warn(references[instruction[2]])
	elseif instruction[1] == "GetProperty" then
		local value = references[instruction[2]][instruction[3]]
		if instruction[4] then references[instruction[4]] = value end
		return value
	elseif instruction[1] == "Clone" then
		references[instruction[3]] = references[instruction[2]]:Clone()
		return references[instruction[3]]
	elseif instruction[1] == "GetReference" then
		return references[instruction[2]]
	elseif instruction[1] == "ExitCondition" then
		if references[instruction[2]] then
			return "__ASSEMBLYEXIT__"
		end
	elseif instruction[1] == "CallMethod" then
		local parameters = instruction[4]
		for i, v in next, parameters do
			if typeof(v) == "table" and v.IsReference then
				parameters[i] = readInstruction(references, v)
			end
		end
		
		references[instruction[2]][instruction[3]](references[instruction[2]], unpack(parameters))
	elseif instruction[1] == "Add" then
		return references[instruction[2]] + instruction[3]
	end
end

Replicator.getInstanceFromReference = getInstanceFromReference
Replicator.readInstruction = readInstruction

return Replicator]]></ProtectedString>
				<string name="ScriptGuid">{6CC6E7B7-03E3-4332-B11C-38B6BFDFF475}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Replicator</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>
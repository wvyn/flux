<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
    <Meta name="ExplicitAutoJoints">true</Meta>
    <Item class="ModuleScript" referent="RBX8TG9QZBN42F9FEMC6VDOWLX6JKTTVZ9O">
        <Properties>
            <string name="Name">InstanceEncoding</string>
            <string name="ScriptGuid">{8a9e9df9-c168-41c5-9a7c-61219ea3d3a5}</string>
            <ProtectedString name="Source"><![CDATA[-- Instance Encoding
local assetService = game:GetService("AssetService")

local Signal = require("./Signal")
local GUID = require("./GUID")

local InstanceEncoding = {}

local readOnly = {
	-- Instance
	"ClassName",
	
	-- Custom
	"__IE",
	"Children",
	"Tags",
	"Attributes",
	
	-- MeshPart
	"MeshContent",
	"TextureContent"
}

local Encodings = {
	BasePart = {
		"Anchored", "CanCollide", "CanQuery", "CanTouch", "CastShadow",
		"PivotOffset", "CollisionGroup", "Reflectance", "CFrame", "Color",
		"Material", "Massless", "Transparency", "Size"
	},

	RemoteEvent = {},
	RemoteFunction = {},
	BindableEvent = {},
	BindableFunction = {},
	
	ParticleEmitter = { 
		"Color", "LightEmission", "LightInfluence", "Orientation", "Size", "Squash", "Texture", "Transparency",
		"ZOffset", "EmissionDirection", "Enabled", "Lifetime", "Rate", "Rotation", "RotSpeed", "Speed", "SpreadAngle",
		"Shape", "ShapeInOut", "ShapeStyle", "FlipbookLayout", "Acceleration", "Drag", "LockedToPart", "TimeScale", "VelocityInheritance",
		"WindAffectsDrag", "FlipbookMode", "FlipbookFramerate", "FlipbookStartRandom"
	},

	Animation = { "AnimationId" },
	Model = { "PrimaryPart", "ModelStreamingMode" },
	Folder = {},

	MeshPart = { "MeshContent", "TextureContent" },

	Shirt = { "ShirtTemplate", "Color3" },
	Pants = { "PantsTemplate", "Color3" },

	Weld = { "C0", "C1", "Part0", "Part1", "Enabled" },
	Motor6D = { "C0", "C1", "Part0", "Part1", "CurrentAngle", "DesiredAngle", "MaxVelocity", "Enabled" },
	RigidConstraint = { "Color", "Visible", "Enabled", "Attachment0", "Attachment1" },

	ValueBase = { "Value" },

	Humanoid = { 
		"CameraOffset",  "DisplayDistanceType", "DisplayName",
		"HealthDisplayDistance", "HealthDisplayType","NameDisplayDistance", "NameOcclusion",
		"RigType", "BreakJointsOnDeath", "EvaluateStateMachine", "RequiresNeck", "AutoRotate",
		"Jump", "PlatformStand", "Sit", "Health", "HipHeight", "AutomaticScalingEnabled", "MaxHealth", "MaxSlopeAngle",
		"WalkSpeed", "AutoJumpEnabled", "JumpPower", "JumpHeight", "UseJumpPower"
	},

	HumanoidDescription = { 
		"BackAccessory", "FaceAccessory", "FrontAccessory", "HairAccessory", "HatAccessory",
		"NeckAccessory", "ShouldersAccessory", "ClimbAnimation", "FallAnimation", "IdleAnimation", "JumpAnimation",
		"MoodAnimation", "RunAnimation", "SwimAnimation", "WalkAnimation", "HeadColor", "LeftArmColor", "LeftLegColor",
		"RightArmColor", "RightLegColor", "TorsoColor", "Face", "Head", "LeftArm", "LeftLeg", "RightArm", "RightLeg", "Torso",
		"GraphicTShirt", "Pants", "Shirt", "BodyTypeScale", "DepthScale", "HeadScale", "HeightScale", "WidthScale", "ProportionScale"
	},

	BodyPartDescription = { "AssetId", "BodyPart", "Color", "Instance" },
	BodyColors = { "HeadColor3", "LeftArmColor3", "LeftLegColor3", "RightArmColor3", "RightLegColor3", "TorsoColor3" },

	SpecialMesh = { "MeshId", "MeshType", "Offset", "Scale", "TextureId", "VertexColor" },

	Animator = { "PreferLodEnabled" },
	Decal = { "Color3", "Texture", "TextureContent", "Transparency", "ZIndex" },
	Attachment = { "Visible", "CFrame", "Axis", "SecondaryAxis" }
}

local function encodeBaseInstance(instance: Instance): EncodedBaseInstance
	return {
		__IE = GUID.new(),
		Archivable = instance.Archivable,
		ClassName = instance.ClassName,
		Name = instance.Name,
		Children = {},
		Tags = instance:GetTags(),
		Attributes = instance:GetAttributes()
	}
end

function InstanceEncoding.EncodeInstance(self: InstanceEncoding, instance: Instance, _instances: {}?, _instanceProperties: {}?)
	local encodedInstance = encodeBaseInstance(instance)
	
	local instances = _instances or {}
	local instanceProperties = _instanceProperties or {}
	
	for classType, properties in next, Encodings do
		if instance:IsA(classType) then
			for _, property in next, properties do
				local value = instance[property]
				if typeof(value) == "Instance" then
					instanceProperties[#instanceProperties + 1] = { Encoded = encodedInstance, Property = property, Value = value }
				end
				encodedInstance[property] = value
			end
		end
		
		instances[instance] = encodedInstance
	end
	
	local children = encodedInstance.Children
	for _, instanceChildren in next, instance:GetChildren() do
		children[#children + 1] = self:EncodeInstance(instanceChildren, instances, instanceProperties)
	end
	
	for _, propertyData in next, instanceProperties do
		local value = instances[propertyData.Value]
		if value then
			propertyData.Encoded[propertyData.Property] = { __IE = value.__IE }
			table.remove(instanceProperties, table.find(instanceProperties, propertyData))
		end
	end
	
	return encodedInstance
end

local function applyDecodedProperties(instance: Instance, properties: EncodedBasePart, instanceProperties: {})
	for propertyIndex, propertyValue in next, properties do
		if table.find(readOnly, propertyIndex) then continue end
		if typeof(propertyValue) == "table" and propertyValue.__IE then
			instanceProperties[#instanceProperties + 1] = { Instance = instance, Property = propertyIndex, Target = propertyValue.__IE }
		else
			instance[propertyIndex] = propertyValue
		end
	end

	for _, tag in next, properties.Tags do
		instance:AddTag(tag)
	end; for attributeName, value in next, properties.Attributes do
		instance:SetAttribute(attributeName, value)
	end
end

function InstanceEncoding.DecodeInstance(self: InstanceEncoding, encodedInstance: EncodedBasePart, responseForward: DecodeResponse?, _instances: {}?, _instanceProperties: {}?): DecodeResponse
	local instances = _instances or {}
	local instanceProperties = _instanceProperties or {}
	
	local instance: Instance
	if encodedInstance.ClassName == "MeshPart" then
		local meshPart = assetService:CreateMeshPartAsync(encodedInstance.MeshContent)
		applyDecodedProperties(meshPart, encodedInstance, instanceProperties)
		instance = meshPart
	else
		local container = Instance.new(encodedInstance.ClassName)
		applyDecodedProperties(container, encodedInstance, instanceProperties)
		instance = container
	end
	
	instances[encodedInstance.__IE] = instance
	
	responseForward = responseForward or {}
	local response = {
		IsLoaded = #encodedInstance.Children == 0,
		LoadedIndex = 1,
		Instance = instance,
		
		Threads = {} :: { thread },
		
		-- Events
		DescendantLoaded = responseForward.DescendantLoaded or Signal.new(),
		ChildLoaded = Signal.new(),
		Loaded = Signal.new(),
	}
	
	for _, children in next, encodedInstance.Children do
		response.Threads[#response.Threads + 1] = task.spawn(function()
			local childrenInstance = self:DecodeInstance(children, response, instances, instanceProperties)
			if not childrenInstance.IsLoaded then childrenInstance.Loaded:Wait() end
			childrenInstance.Instance.Parent = instance
			
			response.LoadedIndex += 1
			if response.LoadedIndex - 1 == #encodedInstance.Children then
				response.IsLoaded = true
				response.Loaded:Fire(childrenInstance)
			end
			
			response.ChildLoaded:Fire(childrenInstance)
			response.DescendantLoaded:Fire(childrenInstance)
		end)
	end
	
	for _, propertyData in next, instanceProperties do
		local value = instances[propertyData.Target]
		if value then
			propertyData.Instance[propertyData.Property] = value
			table.remove(instanceProperties, table.find(instanceProperties, propertyData))
		end
	end
	
	return response
end

export type DecodeResponse = {
	IsLoaded: boolean,
	LoadedIndex: number,
	Instance: Instance,
	
	DescendantLoaded: Signal.Signal,
	ChildLoaded: Signal.Signal,
	Loaded: Signal.Signal
}

export type EncodedBaseInstance = {
	ClassName: string,
	Name: string,
	Children: { EncodedBaseInstance | EncodedBasePart }
}

export type EncodedBasePart = {
	-- BaseInstance
	ClassName: string,
	Name: string,
	Children: { EncodedBaseInstance | EncodedBasePart },
	
	-- BasePart
	Anchored: boolean,
	CanCollide: boolean,
	CanQuery: boolean,
	CanTouch: boolean,
	CastShadow: boolean,
	PivotOffset: Vector3,
	CollisionGroup: string,
	Reflectance: number,
	CFrame: CFrame,
	Color: Color3,
	Material: Enum.Material,
	Massless: boolean,
	Transparency: number,
	Size: Vector3
}

export type InstanceEncoding = typeof(InstanceEncoding)

return InstanceEncoding]]></ProtectedString>
        </Properties>
    </Item>
</roblox>